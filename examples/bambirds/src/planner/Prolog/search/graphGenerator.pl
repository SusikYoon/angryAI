%%This class creates nodes by inferencing over the database
%It has different creation algorithms depending on method-call-parameters

:- dynamic hasEdgeToWith/3.
:- dynamic hasOuterEdgeToWith/3.
%%createEdgesForSeGG/1
%createEdgesForSeGG(+Structure)
%creates edges of every object (=nodes) in given structure qualified by:
%Size, Form, Material, Orientation.
%New Predicates will have the following structure: "hasEdgeToWith(Object, OtherObject, Cost)
%After being done with the created Nodes, call the cleanUp()-Methode of this class
createEdgesForSeGG(Structure) :- 
	findall(
		NewEdge,
		createEdgeOfGraphIn(Structure, NewEdge),
		edgesTemp
	).
	
createEdgesFromListSeGG(List) :-
	findall(
		NewEdge,
		createEdgeOfGraphFrom(List, NewEdge),
		edgesTemp
	).

%%createEdgesForAndBirdSeGG/2
%createEdgesForAndBirdSeGG(+Structure, +Bird)
%same as above, but the MaterialEfficiency of the givenBird will be used for edge-length
createEdgesForAndBirdSeGG(Structure, Bird) :-
	(considerBirdForGraph(PreviousBird)) -> 
		retractall(considerBirdForGraph(PreviousBird));
		
		asserta(considerBirdForGraph(Bird)),
		findall(NewEdge, (createEdgeOfGraphIn(Structure, NewEdge)), _Edges).
/*
%%createEdgesFromListAndBirdSeGG/2
%createEdgesFromListAndBirdSeGG(+List, +Bird)
%same as above, but base for Nodes is a List of Objects.
%!!IMPORTANT!! If you insert a List of Objects not (partly-)related It will create unclosed Nodesystems...
%....that can be a problem for any wayfinding algorithm...  
createEdgesFromListAndBirdSeGG(List, Bird) :-
	(considerBirdForGraph(PreviousBird)) -> 
		retractall(considerBirdForGraph(PreviousBird));
		
		asserta(considerBirdForGraph(Bird)),
		findall(NewEdge, (createEdgeOfGraphIn(List, NewEdge)), _Edges).
*/

%%createEdgesFromListAndBirdSeGG/2
%createEdgesFromListAndBirdSeGG(+List, +Bird)
%same as above, but base for Nodes is a List of Objects.
%!!IMPORTANT!! If you insert a List of Objects not (partly-)related It will create unclosed Nodesystems...
%....that can be a problem for any wayfinding algorithm...  
createEdgesFromListAndBirdSeGG(List, Bird) :-
	(considerBirdForGraph(PreviousBird)) -> 
		retractall(considerBirdForGraph(PreviousBird));
		
		asserta(considerBirdForGraph(Bird)),
		findall(NewEdge, (createEdgeOfGraphIn(List, NewEdge)), _Edges).

%%CleanUpGraphSeGG/0
%cleanUpGraphSeGG()
%deletes all predicates created by graph generating methods of this class
cleanUpGraphSeGG() :- 
	retractall(hasEdgeToWith(_Object, _OtherObject, _Cost)),
	retractall(considerBirdForGraph(_Bird)).

%%getNodeCountSeGG/1
%getNodeCountSeGG(-Count)
%returns the count of all predicates generated by methods of this class
getNodeCountSeGG(Count) :-
	aggregate( count, Object^OtherObject^Cost^hasEdgeToWith( Object, OtherObject, Cost ), Count ).
	
%createsGraph
createEdgeOfGraphIn(Structure, NewEdge) :-
	pIsObjectAValidTargetSeGG(Object, Structure),
	pIsObjectAValidTargetSeGG(OtherObject, Structure),
	(
		pCheckUpSeGG(Object, OtherObject, NewEdge);
		%pCheckDownSeGG(Object, OtherObject, NewEdge);
		pCheckLeftSeGG(Object, OtherObject, NewEdge);
		%pCheckRightSeGG(Object, OtherObject, NewEdge);
		pCheckOverSeGG(Object, OtherObject, NewEdge)
		%pCheckBelowSeGG(Object, OtherObject, NewEdge)
	).

%checks if object can be used as a valid nodes
pIsObjectAValidTargetSeGG(Object, Structure) :-
	object(Object),
	(
		hasMaterial(Object, _Material);
		pig(Object)
	),
	belongsTo(Object, Structure).

%checks if one objects lies on another,
%then creates relation/node (with length) based on SizeXFormXMaterialXOrientation. 
pCheckUpSeGG(Object, OtherObject, NewEdge) :-
	(isOn(OtherObject, Object)) -> 
		pSysoSeGG('A isOn B', [OtherObject, Object]),
		createEdge(Object, OtherObject, vertical, NewEdge),
		pSysoSeGG('UP: NewEdge', NewEdge); false.
pCheckDownSeGG(Object, OtherObject, NewEdge) :- 
	(isOn(Object, OtherObject)) -> 
		pSysoSeGG('A isOn B', [Object, OtherObject]),
		createEdge(Object, OtherObject, vertical,NewEdge),
		pSysoSeGG('Down: NewEdge', NewEdge);	false.
% checks if another object can be found on the left side of the given object,
% then creates relation/node (with length) based on SizeXFormXMaterialXOrientation.
pCheckLeftSeGG(Object, OtherObject, NewEdge) :-
	(isLeft(OtherObject, Object)) ->
		pSysoSeGG('A isLeftOf B', [OtherObject, Object]),
		createEdge(Object, OtherObject, horizontal, NewEdge),
		pSysoSeGG('LEFT: NewEdge', NewEdge); false.
% checks if another object can be found on the right side of the given object,
% then creates relation/node (with length) based on SizeXFormXMaterialXOrientation.
pCheckRightSeGG(Object, OtherObject, NewEdge) :-
	(isRight(OtherObject, Object)) ->
		pSysoSeGG('A isRightOf B', [OtherObject, Object]),
		createEdge(Object, OtherObject, horizontal, NewEdge),
		pSysoSeGG('RIGHT: NewEdge', NewEdge); false.
pCheckOverSeGG(Object, OtherObject, NewEdge) :-
	(isOver(OtherObject, Object)) ->
		pSysoSeGG('[SeGG] A isOverOf B', [OtherObject, Object]),
		createEdge(Object, OtherObject, vertical, NewEdge),
		pSysoSeGG('[SeGG] OVER: NewEdge', NewEdge); false.
pCheckBelowSeGG(Object, OtherObject, NewEdge) :-
	(isOver(OtherObject, Object)) ->
		pSysoSeGG('[SeGG] A isOverOf B', [Object, OtherObject]),
		createEdge(OtherObject, Object, vertical, NewEdge),
		pSysoSeGG('[SeGG] OVER: NewEdge', NewEdge); false.
		
createEdge(Root, Target, BadOrientation,NewEdge) :-
	findall(
		Edge,
		(
			pGetEfficiencyValueSeGG(Target, BaseValue),
			% Is Target not a cube/ball and has an Orientation
			(	(not(isOrientationIrrelevant(Target)) , hasOrientation(Target, Orientation)) ->
					%...compare if orientation is unwanted, and change Costs by factor of database
					pCompareToAndChangeSeGG(Orientation, BadOrientation, BaseValue, PreCost1);
					% else: just give cost as is
					PreCost1 = BaseValue
			),
			(
				(hasMaterial(Target, Material)) ->
				pConsiderBirdSeGG(PreCost1, Material, Cost);
				Cost = PreCost1
			),
			(	(hasEdgeToWith(Root,Target, SomeOtherCost)) -> 
				(
					pSysoSeGG('[GG] --------A Edge Does already exist', hasEdgeToWith(Root,Target, SomeOtherCost)),
					NewEdge = []
				);
				(
					asserta(hasEdgeToWith(Root, Target, Cost))),
					pSysoSeGG('[GG] Edge created' , ''),
					Edge = hasEdgeToWith(Root, Target, Cost)
					
			);
				
			false
		),
		Edges
	), nth0(0, Edges, NewEdge),
	pSysoSeGG('Edges', Edges).
	
%isOrientationIrrevelvant(+Object)
%checks if the object is a ball or cube and therefore irrelevant for orientationmodification
isOrientationIrrelevant(Object) :-
	(hasForm(Object, cube);
	hasForm(Object, ball)).

%gets Efficiency values from database, for normal blocks etc.
%values for pigs and tnt are assumed to be 0	
pGetEfficiencyValueSeGG(Object, Value) :-
		(pig(Object); hasMaterial(Object, tnt)) ->
			Value = 0.01;
			hasSize(Object, Size),
			hasForm(Object, Form),
			hasMaterial(Object, Material),
			efficiencySizeForm(Size, Form, Material, Value).

%pCompareToAndChangeSeGG(+Orientation, +ShouldNotBe, +Value, -ValueChanged)
%validates given orientation against the "ShouldNotBe" orientation.
%If it has the "wrong" orientation, a factor (from DataBase) is applied to the value.
%Else value is returned as is! 		
pCompareToAndChangeSeGG(Orientation, ShouldNotBe, Value, ValueChanged) :-
		(Orientation == ShouldNotBe) ->
			efficiencyFactorForOrientation(Factor),
			ValueChanged is Value*Factor;
			ValueChanged = Value.
%pConsiderBirdSeGG(+PreCost, -Cost)
%!!Only changes Precost if "considerBirdForGraph(Bird)"-Predicate exists!!!!
%Factors Bird-Resistances into Precosts and returns resulting costs
%Precosts should be some kind of efficiency value from database
pConsiderBirdSeGG(PreCost, ObjectMaterial, Cost) :- 
	(considerBirdForGraph(Bird)) ->
		hasColor(Bird, Color),
		( (efficiencyBirdMaterial(Color, ObjectMaterial, Factor)) ->
				Cost is PreCost*Factor; false
		);	
		Cost = PreCost.
		
pSysoSeGG(_Text, _Value) :- %syso(_Text, _Value),
	true.